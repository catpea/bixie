<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Media Gallery</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üòµ‚Äçüí´</text></svg>" />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, sans-serif;
        background: #f5f5f5;
        color: #333;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background: #1a1a1a;
          color: #e0e0e0;
        }
        .media-item {
          background: #2a2a2a;
        }
      }

      .container {
        max-width: 500px;
        margin: 0 auto;
        padding: 20px;
      }

      .header {
        text-align: center;
        margin-bottom: 30px;
        padding: 20px;
      }

      .header h1 {
        font-size: 2rem;
        margin-bottom: 10px;
      }

      .stats {
        font-size: 0.9rem;
        opacity: 0.7;
      }

      .media-grid {
        display: flex;
        flex-direction: column;
        gap: 30px;
      }

      .media-item {
        border-radius: 12px;
        padding: 15px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        transition: transform 0.2s;
      }

      .media-item:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }

      .media-content {
        width: 100%;
        border-radius: 8px;
        overflow: hidden;
        background: #000;
      }

      .media-content img,
      .media-content video {
        width: 100%;
        height: auto;
        display: block;
      }

      .media-info {
        margin-top: 10px;
        padding: 10px;
        text-align: center;
      }

      .file-name {
        font-size: 0.9rem;
        font-weight: 500;
        margin-bottom: 5px;
        word-break: break-word;
      }

      .progress-info {
        font-size: 0.8rem;
        opacity: 0.6;
      }

      .loading-spinner {
        text-align: center;
        padding: 40px;
        font-size: 1.2rem;
      }

      .loading-spinner::after {
        content: "";
        display: inline-block;
        width: 30px;
        height: 30px;
        border: 3px solid rgba(0, 0, 0, 0.1);
        border-top-color: #333;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @media (prefers-color-scheme: dark) {
        .loading-spinner::after {
          border-color: rgba(255, 255, 255, 0.1);
          border-top-color: #fff;
        }
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .error-message {
        text-align: center;
        padding: 40px;
        color: #d32f2f;
      }

      .end-message {
        text-align: center;
        padding: 40px;
      }

      /* Video controls styling */
      video {
        background: #000;
      }

      video::-webkit-media-controls-panel {
        background: linear-gradient(transparent, rgba(0, 0, 0, 0.3));
      }

      .video-status {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 0.8rem;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s;
      }

      .media-item.video-playing .video-status {
        opacity: 1;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <div class="stats" id="stats">Loading...</div>
      </div>

      <div class="media-grid" id="mediaGrid"></div>

      <div class="loading-spinner" id="loadingIndicator" style="display: none"></div>
      <div class="end-message" id="endMessage" style="display: none"><a href="https://github.com/catpea/bixie" style="text-decoration: none;" rel="noreferrer noopener" target="_blank">üòµ‚Äçüí´</a></div>
      <div class="error-message" id="errorMessage" style="display: none"></div>
    </div>

    <script>
      // Configuration
      const ITEMS_PER_LOAD = 5;
      const VIDEO_VISIBILITY_THRESHOLD = 0.5; // 50% visibility required

      // State
      let mediaFiles = [];
      let currentIndex = 0;
      let isLoading = false;
      let allLoaded = false;

      // DOM elements
      const mediaGrid = document.getElementById("mediaGrid");
      const stats = document.getElementById("stats");
      const loadingIndicator = document.getElementById("loadingIndicator");
      const endMessage = document.getElementById("endMessage");
      const errorMessage = document.getElementById("errorMessage");

      // Video tracking
      const activeVideos = new Set();
      const videosPlayingBeforePause = new WeakSet();

      // Initialize the application
      async function init() {
        try {
          await loadFileIndex();
          setupInfiniteScroll();
          loadNextBatch();
        } catch (error) {
          showError("Failed to initialize gallery: " + error.message);
        }
      }

      // Load the file index
      async function loadFileIndex() {
        try {
          const response = await fetch("./index.json");
          if (!response.ok) {
            throw new Error(`Failed to load index: ${response.status}`);
          }
          const data = await response.json();
          mediaFiles = data.files || [];
          updateStats();
        } catch (error) {
          throw new Error("Could not load media index");
        }
      }

      // Update statistics display
      function updateStats() {
        const total = mediaFiles.length;
        const loaded = currentIndex;
        const remaining = total - loaded;

        stats.innerHTML = `
        <span>Total: ${total} files</span> ‚Ä¢
        <span>Loaded: ${loaded}</span> ‚Ä¢
        <span>Remaining: ${remaining}</span>
      `;
      }

      // Setup infinite scroll
      function setupInfiniteScroll() {
        const options = {
          root: null,
          rootMargin: "100px",
          threshold: 0.1,
        };

        const scrollObserver = new IntersectionObserver((entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting && !isLoading && !allLoaded) {
              loadNextBatch();
            }
          });
        }, options);

        // Create sentinel element
        const sentinel = document.createElement("div");
        sentinel.id = "scrollSentinel";
        sentinel.style.height = "1px";
        document.querySelector(".container").appendChild(sentinel);
        scrollObserver.observe(sentinel);
      }

      // Load next batch of items
      async function loadNextBatch() {
        if (isLoading || allLoaded) return;

        isLoading = true;
        loadingIndicator.style.display = "block";

        const batchEnd = Math.min(currentIndex + ITEMS_PER_LOAD, mediaFiles.length);

        for (let i = currentIndex; i < batchEnd; i++) {
          const file = mediaFiles[i];
          await createMediaItem(file, i);
        }

        currentIndex = batchEnd;
        updateStats();

        if (currentIndex >= mediaFiles.length) {
          allLoaded = true;
          endMessage.style.display = "block";
        }

        isLoading = false;
        loadingIndicator.style.display = "none";
      }

      // Create a media item
      async function createMediaItem(file, index) {
        const item = document.createElement("div");
        item.className = "media-item";
        item.dataset.index = index;

        const contentWrapper = document.createElement("div");
        contentWrapper.className = "media-content";

        const isVideo = /\.(mp4|webm|ogg)$/i.test(file.name);

        if (isVideo) {
          const video = document.createElement("video");
          video.src = `files/${file.name}`;
          video.controls = true;
          video.preload = "metadata";
          video.playsInline = true;
          video.muted = false;

          // Track video state changes
          video.addEventListener("play", () => {
            item.classList.add("video-playing");
            activeVideos.add(video);
          });

          video.addEventListener("pause", () => {
            item.classList.remove("video-playing");
            activeVideos.delete(video);
          });

          video.addEventListener("ended", () => {
            item.classList.remove("video-playing");
            activeVideos.delete(video);
          });

          // Setup visibility observer for this video
          setupVideoVisibilityObserver(video);

          contentWrapper.appendChild(video);
        } else {
          const img = document.createElement("img");
          img.src = `files/${file.name}`;
          img.alt = file.name;
          img.loading = "lazy";
          contentWrapper.appendChild(img);
        }

        const info = document.createElement("div");
        info.className = "media-info";

        const fileName = document.createElement("div");
        fileName.className = "file-name";
        // NOT USED AS THIS IS CAS fileName.textContent = file.name;

        const progress = document.createElement("div");
        progress.className = "progress-info";
        const percentage = (((index + 1) / mediaFiles.length) * 100).toFixed(1);
        progress.textContent = `${index + 1} of ${mediaFiles.length} (${percentage}%)`;

        info.appendChild(fileName);
        info.appendChild(progress);

        item.appendChild(contentWrapper);
        item.appendChild(info);

        mediaGrid.appendChild(item);
      }

      // Setup visibility observer for videos
      function setupVideoVisibilityObserver(video) {
        const options = {
          root: null,
          rootMargin: "0px",
          threshold: [0, VIDEO_VISIBILITY_THRESHOLD],
        };

        const observer = new IntersectionObserver((entries) => {
          entries.forEach((entry) => {
            const video = entry.target;
            const isVisible = entry.intersectionRatio >= VIDEO_VISIBILITY_THRESHOLD;

            if (!isVisible) {
              // Video is going out of view
              if (!video.paused && !video.ended) {
                videosPlayingBeforePause.add(video);
                video.pause();
                console.log("Paused video:", video.src);
              }
            } else {
              // Video is coming into view
              if (videosPlayingBeforePause.has(video)) {
                video
                  .play()
                  .then(() => {
                    videosPlayingBeforePause.delete(video);
                    console.log("Resumed video:", video.src);
                  })
                  .catch((err) => {
                    // Autoplay was prevented
                    console.log("Could not auto-resume video:", err.message);
                    videosPlayingBeforePause.delete(video);
                  });
              }
            }
          });
        }, options);

        observer.observe(video);
      }

      // Show error message
      function showError(message) {
        errorMessage.textContent = message;
        errorMessage.style.display = "block";
        loadingIndicator.style.display = "none";
      }

      // Pause all videos (utility function)
      function pauseAllVideos() {
        activeVideos.forEach((video) => {
          if (!video.paused) {
            video.pause();
          }
        });
      }

      // Handle page visibility changes
      document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          pauseAllVideos();
        }
      });

      // Start the application
      init();
    </script>
  </body>
</html>
